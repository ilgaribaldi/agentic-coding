# Python Stack

## Stack Choices

| Technology | Version | Purpose |
|-----------|---------|---------|
| Python | 3.12+ (modern apps), 3.10 (web services), 3.9 (legacy/Lambda) | Runtime |
| uv | Latest | Dependency management (modern repos) |
| pip / pip-tools | Latest | Dependency management (legacy repos) |
| Flask | 3.1.x | Web microservice framework |
| Flask-RESTX | Latest | REST API with Swagger |
| SQLAlchemy | 2.0 | ORM + query builder |
| GeoAlchemy2 | Latest | PostGIS spatial types |
| psycopg2-binary | 2.9.x | PostgreSQL adapter (raw SQL) |
| requests | 2.32+ | HTTP client |
| boto3 | 1.42+ | AWS SDK (S3, Secrets Manager, Batch) |
| xarray | Latest | N-D labeled arrays (scientific data) |
| joblib | 1.5+ | Parallel processing |
| pytest | 7+ | Testing |
| Gunicorn | Latest | WSGI server (production) |

## Dependency Management

### uv (Modern Repos)

```toml
# pyproject.toml
[project]
name = "my-project"
version = "0.1.0"
requires-python = ">=3.12"

dependencies = [
    "xarray>=2024.0",
    "numpy>=1.24.0",
    "joblib>=1.4.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=7.0.0",
    "ruff>=0.4.0",
]
notebooks = [
    "jupyter>=1.0.0",
    "pandas>=2.0.0",
]
```

```bash
# Common commands
uv sync --dev              # Install all deps including dev
uv run pytest              # Run in managed environment
uv add requests            # Add dependency
uv add --dev ruff          # Add dev dependency
uv lock                    # Regenerate lockfile
uv python install 3.12     # Install Python version
uv python pin 3.12         # Pin version in .python-version
```

- `uv sync` performs exact syncing â€” installs locked deps and removes unlocked packages
- `uv run` verifies lockfile is up-to-date before every invocation
- `uv lock` produces a single `uv.lock` file for the workspace

### pip / pip-tools (Legacy Repos)

```
# requirements.txt (pinned, generated by pip-compile)
flask==3.1.0
sqlalchemy==2.0.46
psycopg2-binary==2.9.11
```

```bash
pip install -r requirements.txt
pip install -e .              # Editable install for SDK development
```

## Flask Application Factory

```python
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
from flask_caching import Cache
from flask_cors import CORS

db = SQLAlchemy()
migrate = Migrate()
cors = CORS()

def create_app(config_name: str) -> Flask:
    app = Flask(__name__)
    app.config.from_object(config_by_name[config_name])

    cors.init_app(app)
    db.init_app(app)
    migrate.init_app(app, db)

    # Register blueprints
    from .controllers import api as api_blueprint
    app.register_blueprint(api_blueprint)

    return app
```

### Configuration by Environment

```python
class Config:
    """Base configuration."""
    SECRET_KEY = os.getenv("SECRET_KEY", "dev-secret")
    SQLALCHEMY_TRACK_MODIFICATIONS = False

class DevelopmentConfig(Config):
    DEBUG = True
    SQLALCHEMY_DATABASE_URI = os.getenv("DATABASE_URL")

class ProductionConfig(Config):
    DEBUG = False
    SQLALCHEMY_DATABASE_URI = os.getenv("DATABASE_URL")
    SQLALCHEMY_ENGINE_OPTIONS = {
        "pool_pre_ping": True,
        "pool_size": 30,
        "pool_recycle": 5400,
        "connect_args": {
            "keepalives": 1,
            "keepalives_idle": 30,
            "keepalives_interval": 10,
            "keepalives_count": 5,
        },
    }

config_by_name = {
    "dev": DevelopmentConfig,
    "prod": ProductionConfig,
}
```

## Flask-RESTX API Pattern

```python
from flask_restx import Namespace, Resource, reqparse, fields

api = Namespace("weather", description="Weather data operations")

# Request parser with validation
parser = reqparse.RequestParser()
parser.add_argument("lat", type=float, required=True, location="args",
                    help="Latitude (-90 to 90)")
parser.add_argument("lon", type=float, required=True, location="args",
                    help="Longitude (-180 to 180)")
parser.add_argument("var", type=str, required=False, location="args",
                    help="Comma-separated variables")

# Response model
response_model = api.model("WeatherResponse", {
    "data": fields.Raw(description="Weather data"),
    "meta": fields.Raw(description="Metadata"),
})

@api.route("/")
class WeatherAPI(Resource):

    @api.expect(parser, validate=True)
    @api.response(200, "Success", response_model)
    @api.response(400, "Invalid parameters")
    def get(self) -> tuple[dict, int]:
        """Retrieve weather data."""
        args = parser.parse_args()
        # ... process request
        return {"data": result, "meta": metadata}, 200
```

## Secret Management

### AWS Secrets Manager with Fallback

```python
import boto3
import json
import os

def get_secret(secret_name: str, region: str = "us-east-1") -> dict:
    """Get secret from AWS Secrets Manager."""
    client = boto3.client("secretsmanager", region_name=region)
    response = client.get_secret_value(SecretId=secret_name)
    return json.loads(response["SecretString"])

def get_config(use_env: bool = False) -> dict:
    """Get config from Secrets Manager or environment variables."""
    if use_env:
        return {
            "DATABASE_URL": os.environ["DATABASE_URL"],
            "EXTERNAL_API_KEY": os.environ["EXTERNAL_API_KEY"],
            "EXTERNAL_API_BASE_URL": os.environ["EXTERNAL_API_BASE_URL"],
        }
    return get_secret("my-app/config")
```

- `--use-env` flag for local development (reads `.env` or shell vars)
- AWS Secrets Manager for production (no `.env` files in containers)

## Deployment Patterns

### Gunicorn + Docker (Flask)

```dockerfile
FROM python:3.10-bullseye
WORKDIR /usr/src/app
COPY requirements/ requirements/
RUN pip install -r requirements/requirements.txt
COPY . .
ENTRYPOINT gunicorn --bind :$PORT -c ./gunicorn.config.py --timeout 0 manage:app
```

```python
# gunicorn.config.py
import os

workers = int(os.environ.get("GUNICORN_WORKERS", "4"))
threads = int(os.environ.get("GUNICORN_THREADS", "8"))
loglevel = os.environ.get("GUNICORN_LOGLEVEL", "INFO")
capture_output = True
reload = True
```

### AWS Lambda (Serverless)

```dockerfile
FROM public.ecr.aws/lambda/python:3.9
COPY requirements.txt ${LAMBDA_TASK_ROOT}
RUN pip install --target ${LAMBDA_TASK_ROOT} -r requirements.txt
COPY . ${LAMBDA_TASK_ROOT}
ENV FLASK_APP=src.app
CMD ["src.app.lambda_handler"]
```

### CLI Entry Points (argparse)

```python
import argparse

def main():
    parser = argparse.ArgumentParser(description="Run risk computation")

    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("--model_id", type=str, help="Run single model")
    group.add_argument("--org", type=str, help="Run all models for org")
    group.add_argument("--all", action="store_true", help="Run all models")

    parser.add_argument("--use-env", action="store_true",
                        help="Use env vars instead of AWS Secrets Manager")
    parser.add_argument("--n_jobs", type=int, default=1,
                        help="Parallel workers for hazard processing")

    args = parser.parse_args()

    config = get_config(use_env=args.use_env)

    if args.model_id:
        run_model(args.model_id, config, args.n_jobs)
    elif args.org:
        run_org(args.org, config, args.n_jobs)
    elif args.all:
        run_all(config, args.n_jobs)

if __name__ == "__main__":
    main()
```

## Logging

### Standard Pattern

```python
import logging

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s"
)
logger = logging.getLogger(__name__)

# Usage
logger.info(f"Processing {len(items)} items")
logger.warning(f"Transient error, retrying: {e}")
logger.error(f"Failed to process: {e}", exc_info=True)
```

### Production (Datadog JSON)

```python
class DatadogJSONFormatter(logging.Formatter):
    def format(self, record):
        log_record = {
            "timestamp": self.formatTime(record),
            "level": record.levelname,
            "logger": record.name,
            "message": record.getMessage(),
            "dd": {
                "trace_id": getattr(record, "dd.trace_id", "0"),
                "span_id": getattr(record, "dd.span_id", "0"),
            },
        }
        if record.exc_info:
            log_record["error"] = {"stack": self.formatException(record.exc_info)}
        return json.dumps(log_record)
```

## Custom Exceptions

```python
class InputError(Exception):
    """Invalid input argument."""
    pass

class DatasetNotAvailableError(InputError):
    """Dataset with given conditions does not exist."""
    pass

class VariableNotAvailableError(InputError):
    """Variable does not exist within dataset."""
    pass

class NoDataError(Exception):
    """Valid inputs but no data to retrieve."""
    pass
```

## Docs

- [uv](https://docs.astral.sh/uv/)
- [Flask](https://flask.palletsprojects.com/en/3.1.x/)
- [Flask-RESTX](https://flask-restx.readthedocs.io/)
- [SQLAlchemy 2.0](https://docs.sqlalchemy.org/en/20/)
- [GeoAlchemy2](https://geoalchemy-2.readthedocs.io/en/stable/)
- [psycopg2](https://www.psycopg.org/docs/)
- [boto3](https://boto3.amazonaws.com/v1/documentation/api/latest/index.html)
- [Gunicorn](https://docs.gunicorn.org/)
